# 3.2.4 硬编码存在什么问题？

经过上文两节，我们实现了一个用户微服务，还实现了一个电影微服务，并在电影微服务中使用RestTemplate调用用户微服务中的RESTful接口。一切都是那么的自然、简单，perfect！那么上文的代码真的完美吗？我们来分析一下上文的代码：在服务消费者MovieController.java中：

```java
  @GetMapping("/simple/{id}")
  public User findById(@PathVariable Long id) {
    return this.restTemplate.getForObject(this.userServiceUrl + "1", User.class);
  }
```

我们可以看到：电影微服务读取配置文件`application.yml` 中的配置项`userServiceUrl: http://localhost:7900/` ，然后请求`http://localhost:7900/1` 。

也就是说，我们是把配置硬编码在配置文件中的。在传统的开发中，我们往往也是这么做的。但是这样存在什么样的问题呢？

* 适用场景有局限

如果服务提供者的网络地址发生了变化，将会影响服务消费者。例如：我们对用户服务进行了修改并重新发布，此时该服务的网络地址发生了变化，这将会导致电影微服务的异常——我们需要修改电影微服务的配置，并重新发布。这显然是不可取的。

* 无法动态伸缩

在生产环境中，每个微服务往往部署多个实例，以完成容灾和伸缩。在微服务中，系统往往是自动伸缩的，硬编码无法适应这种需求。

尽管可以借助Nginx等反向代理软件对用户微服务进行反向代理，以适应这种需求，但是手动对Nginx的配置也是很麻烦的。

* 如何解决？

那么要如何解决这样的问题呢？且听下回分解。

